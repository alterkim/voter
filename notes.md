# Some random notes on my journey with cosmos SDK

Disclaimer: Some of this can be interesting, some other stuff may be wrong because I'm quite new to the SDK. I've used Tendermint extensively when building BigchainDB 2.0.

## On testing

### simapp

The code generated by `starport` doesn't incentivize writing tests. The first thing I've noticed is that to test my module I need a `simapp`. `starport` should generate the `simapp` as well and at least one test. I got great support from Billy (thanks!), and without him writing a test would have been more painful.

### Level of abstraction of the Keeper

In the [NFT module](https://github.com/cosmos/modules/blob/afaac0f3116c21bd84cc6320a54176612f5524ac/incubator/nft/handler_test.go#L76) tests, the keeper returns a struct with the NFT data:

```go
    nftAfterwards, err := app.NFTKeeper.GetNFT(ctx, denom, id)
    require.NoError(t, err)
    require.True(t, nftAfterwards.GetOwner().Equals(address2))
```

This makes it easy to make assetions on the data contained in the NFT.

The generated code `ListPoll` returns a bytearray:

```go
func ListPoll(ctx sdk.Context, k Keeper) ([]byte, error) {
    var pollList []types.Poll
    store := ctx.KVStore(k.storeKey)
    iterator := sdk.KVStorePrefixIterator(store, []byte(types.PollPrefix))
    for ; iterator.Valid(); iterator.Next() {
        var poll types.Poll
        k.cdc.MustUnmarshalBinaryLengthPrefixed(store.Get(iterator.Key()), &poll)
        pollList = append(pollList, poll)
    }
    res := codec.MustMarshalJSONIndent(k.cdc, pollList)
    return res, nil
}
```

*Note: originally the function was called `listPoll` (lowercase `l`), but I wanted to use it in a test so I had to capitalize it.*

And in my tests I have to use the `MustUnmarshalJSON` from the codec.

```go
func TestMsgCreatePoll(t *testing.T) {
    var pollList []types.Poll
    app, ctx := createTestApp(false)
    k := app.VoterKeeper
    h := voter.NewHandler(k)
    m := types.NewMsgCreatePoll(address, "A title", "options")
    _, err := h(ctx, m)
    require.Nil(t, err)
    res, _ := keeper.ListPoll(ctx, k)
    types.ModuleCdc.MustUnmarshalJSON(res, &pollList)
    fmt.Println("antani")
    fmt.Printf("%+v\n", pollList)
}
```

I'm confused because I would expect the Keeper to work (both in and out) with structs, and this seems also the behavior of the keeper in the [NFT module](https://github.com/cosmos/modules/tree/c67759bd79c5c224cc1ba754b8d49dec838f593a/incubator/nft/keeper).

### Addresses

When testing you need to generate some addresses. I found this code (writing it from scratch would have required some time):

```go
package simapp

import (
    "bytes"
    "strconv"

    sdk "github.com/cosmos/cosmos-sdk/types"
)

// CreateTestAddrs creates test addresses
func CreateTestAddrs(numAddrs int) []sdk.AccAddress {
    var addresses []sdk.AccAddress
    var buffer bytes.Buffer

    // start at 100 so we can make up to 999 test addresses with valid test addresses
    for i := 100; i < (numAddrs + 100); i++ {
        numString := strconv.Itoa(i)
        buffer.WriteString("A58856F0FD53BF058B4909A21AEC019107BA6") //base address string

        buffer.WriteString(numString) //adding on final two digits to make addresses unique
        res, _ := sdk.AccAddressFromHex(buffer.String())
        bech := res.String()
        addresses = append(addresses, testAddr(buffer.String(), bech))
        buffer.Reset()
    }
    return addresses
}

// for incode address generation
func testAddr(addr string, bech string) sdk.AccAddress {
    res, err := sdk.AccAddressFromHex(addr)
    if err != nil {
        panic(err)
    }
    bechexpected := res.String()
    if bech != bechexpected {
        panic("Bech encoding doesn't match reference")
    }

    bechres, err := sdk.AccAddressFromBech32(bech)
    if err != nil {
        panic(err)
    }
    if !bytes.Equal(bechres, res) {
        panic("Bech decode and hex decode don't match")
    }

    return res
}
```
Would be great to have some sort of utils to do this. I'm wondering if [AddNewKey](https://godoc.org/github.com/cosmos/cosmos-sdk/client/keys#NewAddNewKey) can be used.

## Other things

### Functions or Methods?

Why `CreatePoll` is a method while `ListPoll` isn't? What's the best practice?

```go
func (k Keeper) CreatePoll(ctx sdk.Context, poll types.Poll)
```

```go
func ListPoll(ctx sdk.Context, k Keeper) ([]byte, error)
```


## On frontend generation

Having a `vue` app for free is pretty nice, so I can start interacting immediately with my backend, but it's a really opinionated choice. I don't know `vue`, and in general I would prefer a more *vanilla* approach, where I have some code samples that use the JavaScript SDK to interact with the REST endpoints.
